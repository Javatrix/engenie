// File generated by battery::embed
// DO NOT EDIT THIS FILE!!!
#ifndef BATTERY_EMBED_HPP
#define BATTERY_EMBED_HPP

#include <vector>
#include <string>
#include <string_view>
#include <stdexcept>
#include <sstream>
#include <functional>
#include <cstdint>

#ifndef __cpp_constexpr_dynamic_alloc
#   error "battery::embed requires C++20"
#endif

namespace b {

    struct EmbedInternal {

        class EmbeddedFile {
        public:
            constexpr EmbeddedFile() = default;
#ifdef B_PRODUCTION_MODE
            constexpr EmbeddedFile(const std::string_view& data, const std::string_view& filename)
                : m_data(data), m_filename(filename) {};
#else
            constexpr EmbeddedFile(const std::string_view& data, const std::string_view& filename, const std::string_view& fullFilepath)
                : m_data(data), m_filename(filename), m_fullFilepath(fullFilepath) {};
#endif

            std::string str() const {
                return m_data.data();
            }

            const char* data() const {
                return m_data.data();
            }

            std::vector<uint8_t> vec() const {
                return std::vector<uint8_t>(m_data.begin(), m_data.end());
            }

            size_t length() const {
                return m_data.size();
            }

            size_t size() const {
                return m_data.size();
            }

            operator std::string() {
                return str();
            }

            operator std::vector<uint8_t>() {
                return vec();
            }

            void get(const std::function<void(const b::EmbedInternal::EmbeddedFile&)>& callback);

        private:
            std::string_view m_data;
            std::string_view m_filename;
#ifndef B_PRODUCTION_MODE
            std::string_view m_fullFilepath;
#endif
        }; // class EmbeddedFile

        ${EMBEDDED_FILES_DECLARATIONS}
    };   // struct embedded_files

    template<size_t N>
    struct embed_string_literal {
        constexpr embed_string_literal(const char (&str)[N]) {
            std::copy_n(str, N, value);
        }
        constexpr bool operator!=(const embed_string_literal& other) const {
            return std::equal(value, value + N, other.value);
        }
        std::string str() const {
            return std::string(value, N);
        }
        constexpr bool _false() const {
            return false;
        }
        char value[N];
    };

    template<size_t N, size_t M>
    constexpr bool operator==(const embed_string_literal<N>& left, const char (&right)[M]) {
        return std::equal(left.value, left.value + N, right);
    }

    template<embed_string_literal identifier>
    constexpr EmbedInternal::EmbeddedFile embed() {
        ${EMBEDDED_FILES_RETURNS}{
            static_assert(identifier._false(), "[b::embed<>] No such file or directory");
        }
    }

} // namespace b

inline std::ostream& operator<<(std::ostream& stream, const b::EmbedInternal::EmbeddedFile& file) {
    stream << file.str();
    return stream;
}

#endif // BATTERY_EMBED_HPP
